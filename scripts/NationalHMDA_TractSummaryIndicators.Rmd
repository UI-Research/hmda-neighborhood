---
title: "Neighborhood Indicators from Home Mortgage Disclosure Act (HMDA) Data"
output: html_document
date: '2023-11-08'
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  echo = F,
  include = T,
  eval = T,
  message = F,
  warning = F)
```

```{r Libraries}
library(dtplyr)
library(tidyverse)
library(here)
library(skimr)
library(arrow)
```

```{r Metadata}
## Run this the first time you clone / pull this repository.
## This will ensure you've loaded the same package versions as were used in the
## development of these data:
# options(renv.consent = TRUE) ## this allows renv to modify files in your project directory
# renv::restore()

#Update this value to the appropriate year
year = "2018"

#Relative path to the raw HMDA dataset (.parquet) - ~1.1 GB
hmda_path = here("data-raw") %>% list.files(full.names = T) %>% str_match(paste0(".*", year, ".*\\.parquet")) %>% .[!is.na(.)] 

#Data source: https://www.huduser.gov/portal/datasets/il/il21/Section8-FY21.xlsx
#Path to income limit data (csv):
income_limits_path <- here("data-raw", "income-limits", paste0("Section8-FY", str_sub(year, 3, 4), ".csv"))

#Path to codebook (.xlsx)
codebook_path = here("Urban-HMDA_neighborhood_data_codebook_external.xlsx")

#Path to subcounty-to-tract crosswalk from geocorr for 2010-based geographies (.csv) 
#To be used with HMDA data up until 2022
if (as.numeric(year) < 2022) {
  geocorr_xwalk_path = here("data-raw", "geocorr_subcounty_tract_landarea_2018.csv") ## 2018 is the year of the geocorr application
} else { geocorr_xwalk_path = here("data-raw", "geocorr_subcounty_tract_landarea_2022.csv") } ## 2022 is the year of the geocorr application

## in cases where the ACS year would use 2020 Census tract geographies, but HMDA data are still
## reported in 2010 Census tract geographies, use 2019 as the ACS data year
## for years after 
acs_year = year
if (year %in% c("2020", "2021")) { acs_year = "2019"}
if ((year %>% as.numeric) > 2021) { acs_year = (lubridate::year(Sys.Date()) - 2) %>% as.character }

#Path to locally-saved ACS data (csv)
acs_file_path = here("data-raw", paste0("acs_5yr_", acs_year, "_owner_occupied_housing.csv"))


## create a folder for data outputs if it doesn't exist
if (!dir.exists(here("data-final"))) { dir.create(here("data-final")) }

#Path to write final dataset (csv)
output_path = here("data-final", paste0("hmda_tract_", year, ".csv"))

if ( !file.exists(hmda_path) ) { stop(paste0("There is no HMDA data file at the designated path: ", hmda_path)) }
if ( !file.exists(income_limits_path) ) { stop(paste0("There is no income limits data file at the designated path: ", income_limits_path)) }
if ( !file.exists(codebook_path) ) { stop(paste0("There is no codebook at the designated path: ", codebook_path)) }

print(paste0("Running this script where 'year' = ", year, " and 'acs_year' = ", acs_year, "."))
```

```{r Step 1 - Read Raw HMDA Data, cache = F}
# Read national HMDA file
starttime <- Sys.time()
print(paste("Start Time", starttime))
print(paste("Step 1: Read national HMDA file:", Sys.time()))

#The relevant income limits columns
income_limits_columns = c(
  "State",
  "County",
  "fips2010", # subcounty FIPS
  "l50_4",
  "l80_4")

#The relevant HMDA columns
hmda_columns = c(
  "state_code",
  "county_code",
  "census_tract",
  "income",
  "loan_type",
  "loan_amount",
  "loan_purpose",
  "derived_dwelling_category",
  "action_taken",
  "lien_status",
  "occupancy_type",
  "applicant_ethnicity_1",
  "co_applicant_race_2",
  "co_applicant_ethnicity_1",
  "applicant_race_1",
  "co_applicant_race_1",
  "applicant_race_2",
  "derived_sex",
  "applicant_age",
  "co_applicant_age",
  "purchaser_type")

#Reading the HMDA parquet file
#Only reading in the needed columns to limit file size
hmda_raw <- read_parquet(file = hmda_path, col_select = all_of(hmda_columns)) %>%
  mutate(
    #If the census tract is coded as "na" then switch to proper missing
    census_tract = case_when(
      census_tract %in% c("na", "nA", "Na") ~ as.character(NA), 
      TRUE ~ as.character(census_tract)),
    
    #If the county is coded as "na" or "99999" then switch to proper missing
    #This is five characters
    county_code = case_when(
      county_code %in% c("na","N/AN/", "nA", "Na", "99999") ~ as.character(NA), 
      TRUE ~ as.character(county_code)),
    
    #Check the state part of the county code
    state_code = substr(county_code, 1, 2),
    
    # 00, 03, 07, and 80 are not state FIPS codes
    # note that 60 = Americaon Samoa, 66 = Guam, 72 = PR, 78 = USVI
    county_code =  case_when(
      state_code %in% c("00", "03", "07", "80") ~ as.character(NA), 
      TRUE ~ as.character(county_code))) #%>%
  ## For testing purposes only, un-comment this to run on a subset of all records
  # arrange(county_code) %>%
  # slice_sample(n = 10000)

#hmda_raw = hmda_raw1 %>% filter(state_code == "01")
```

```{r Step 2 - Read Income Limits and Tract-Subcounty Crosswalk, cache = F}
# Read income limits file and define max limits for each county
print(paste("Step 2: Read income limits file and define max limits for each county:", Sys.time()))

income_limits_raw <- read_csv(income_limits_path) %>%
  janitor::clean_names() %>% 
  transmute(
    state_code = str_sub(fips2010, 1, 2), ## two characters
    county_code = str_sub(fips2010, 3, 5), ## three characters
    ## 10 characters -- state code plus county_code plus either five "9" characters
    ## (in the case that there is no subcounty unit) or the five-character subcounty code
    state_subcounty_code = fips2010,
    #Create combined state + county code - five characters
    county_fips = paste0(state_code, county_code),
    #Very low income max (Under 50% AMI)
    income_limit_very_low = l50_4, 
    #Low income max (50-80% AMI)
    income_limit_low = l80_4,
    #Medium income max (80-100% AMI)
    income_limit_moderate = (l80_4 / .8) * 1.2) %>%
  add_count(county_fips, name = "county_count") %>%
  ## most counties have a single set of income limits that apply to the entire county
  ## however, some counties have multiple income limits, each of which corresponds to
  ## a county subdivision. we create a join key that equals either the county code ("county_fips")
  ## or the county subdivision code ("fips2010") depending on the number of income limits for 
  ## county ("county_count")
  mutate(join_key = if_else(county_count > 1, state_subcounty_code, county_fips)) %>%
  select(join_key, county_fips, matches("income_limit"), county_count)

## income limits vary at a subcounty geography for some counties
## to accurately join these income limits to tracts (at which we're calculating HMDA characteristics)
## we leverage a subcounty-to-tract crosswalk obtained from geocorr: https://mcdc.missouri.edu/applications/geocorr2018.html
## we then assign to each tract the income limit for the subcounty geography that most overlaps with that tract by land area
## as reflected in the "afact" column
## as of 2022 data, HMDA has shifted to using 2020-vintage census tract geographies
## these necessitate a different crosswalk

## For years pre-2022
if (as.numeric(year) < 2022) {
  geocorr_xwalk = read_csv(geocorr_xwalk_path) %>%
    ## cleaning up names
    rename(
      county_fips = county, 
      subcounty_fips = cousubfp,
      county_name = cntyname, 
      subcounty_name = cousubnm,
      land_area_mi = LandSQMI,
      subcounty_tract_allocation_factor = afact) %>%
    slice(2:nrow(.)) %>% # dropping a row with variable labels
    mutate(
      census_tract = paste0(county_fips, tract) %>% str_remove_all("\\."), ## cleaning tract codes for joining
      subcounty_tract_allocation_factor = subcounty_tract_allocation_factor %>% as.numeric) %>% # converting to numeric
    # sort by the area of the intersection between the tract and subcounty, then group_by census_tract and select the first row
    # this selects the subcounty that has the greatest land-area-overlap with the tract
    group_by(census_tract) %>%
    arrange(desc(land_area_mi)) %>%
    summarise(across(everything(), first)) %>%
    mutate(
      fips2010 = paste0(county_fips, subcounty_fips),
      join_key = if_else(county_fips %in% ( income_limits_raw %>% filter(county_count == 1) %>% pull(county_fips) ), county_fips, fips2010),
      join_key = case_when(
        ## This county doesn't exist in the income limits data (because the county ceased to exist)
        ## The current county code for this area is 51019.
        str_detect(join_key,"^51515") ~ "51019",
        ## For county 29055 in the income limits data, there are two records with invalid fips2010 values
        ## We assign to all tracts in the county the mean of these incomes limits (since we can't join to the county subdivision). 
        str_detect(join_key, "^29055") ~ "29055",
        T ~ join_key)) %>%
    select(census_tract, join_key) } else {
      
  ## For years 2022-onwards
  geocorr_xwalk = read_csv(geocorr_xwalk_path) %>%
    ## cleaning up names
    rename(
      county_fips = county, 
      subcounty_fips = cousub20,
      county_name = CountyName, 
      subcounty_name = MCDName,
      land_area_mi = LandSQMI,
      subcounty_tract_allocation_factor = afact) %>%
    slice(2:nrow(.)) %>% # dropping a row with variable labels
    mutate(
      census_tract = paste0(county_fips, tract) %>% str_remove_all("\\."), ## cleaning tract codes for joining
      subcounty_tract_allocation_factor = subcounty_tract_allocation_factor %>% as.numeric) %>%
    group_by(census_tract) %>%
    arrange(desc(land_area_mi)) %>%
    summarise(across(everything(), first)) %>%
    mutate(
      fips2010 = paste0(county_fips, subcounty_fips),
      join_key = if_else(county_fips %in% (income_limits_raw %>% filter(county_count == 1) %>% pull(county_fips) ), county_fips, fips2010)) %>%
    select(census_tract, join_key)
  }

## join income limits to the tract-to-subcounty-division crosswalk so that we can
## then associate hmda data (at the tract level) with applicable income limits
tract_level_income_limits = geocorr_xwalk %>%
  ## full join to retain records for American Samoa, PR, USVI, and Guam-based areas that are not included in the crosswalk
  ## but are included in the income limits file; this also joins some rows for areas in the NE with
  ## subcounty income limits where census_tract values don't match--we drop these at the end
  full_join(income_limits_raw, by = "join_key") %>%
  mutate(county_fips = if_else(is.na(county_fips), str_sub(census_tract, start = 1, end = 5), county_fips)) %>%
  group_by(county_fips) %>%
  # Imputing with the county mean income limits in the limited cases (n = ~ 10) where the subcounty join fails
  mutate(
    across(where(is.double), ~ if_else(is.na(.x), mean(.x, na.rm = T), .x)),
    census_tract = if_else( ## creating pseudo tract codes for PR-, Guam-, and USVI-based areas
      ## because these aren't included in the crosswalk
      is.na(census_tract) & !is.na(join_key) & str_detect(join_key, "^66|^72|^78"), 
      paste0(join_key, "999999"),
      census_tract)) %>%
  ungroup() %>%
  select(census_tract, matches("income_limit")) %>%
  ## dropping records where census_tract is missing (these result from the full join)
  filter(!is.na(census_tract))
```

```{r Step 3 - Download ACS Data, cache = F}
# Load state and county codes using {tigris} package
print(paste("Step 3: Download ACS data:", Sys.time()))

#If data is saved locally, then read in from the local path
#Otherwise, use the {tidycensus} package to query the Census API
if (file.exists(acs_file_path)) {
  acs_housing = read_csv(acs_file_path)
  } else {
  # Variable codes for Census query
  acs_vars = c(
    "B25003_001", #total occupied housing units
    "B25003_002") #owner-occupied units
  
  #Map over all states and return 5-year ACS data for the year and variables
  #defined above
  acs_housing = map_dfr(
    datasets::state.abb,
    ~ tidycensus::get_acs(
        state = .,
        variables = acs_vars,
        year = as.numeric(acs_year),
        geography = "tract",
        survey = "acs5",
        output = "wide")) %>%
    #Retain the GEOID and estimates for each queried variable
    select(GEOID, housing_units_occupied_total = B25003_001E, housing_units_occupied_owner = B25003_002E)
  
  #Write the data to the local path so that it's not necessary to query the API in the future
  write_csv(acs_housing, acs_file_path) }
```

```{r Step 4 - Clean Partial and Missing Geography Codes}
# Merge national file and counties, flag and create dummy codes for missing tracts/counties
# Note that this takes approximately 1-2 minutes with 2021 data on a laptop
print(paste("Step 4: Merge national file and counties, flag and create dummy codes for missing tracts/counties:", Sys.time()))

hmda_geo <- hmda_raw %>% 
  mutate(
    # Derive county_code from census_tract when the first is missing and the second is not
    county_code = case_when(
      is.na(county_code) & !is.na(census_tract) ~ str_sub(as.character(census_tract), 1, 5),
      T ~ county_code),
    # Create flag variables for when the tract or county codes are missing
    missing_tract = case_when(is.na(census_tract) ~ 1, TRUE ~ 0), 
    missing_county = case_when(is.na(county_code) ~ 1, TRUE ~ 0),
    geo2010 = case_when(
      # If Census tract is valid then geo2010 is the input census tract
      missing_tract == 0 ~ as.character(census_tract),
      # If the tract is missing but the county is valid then code as state + county + XXXXXX
      missing_tract == 1 & missing_county == 0 ~ as.character(paste0(county_code, "XXXXXX")),
      # If the tract and county are missing then code as state + XXXXXXXXX
      missing_tract == 1 & missing_county == 1 & !is.na(state_code) ~ as.character(paste0(state_code, "XXXXXXXXX")),
      # If the geography is completely invalid, use XXXXXXXXXXX
      TRUE ~ "XXXXXXXXXXX"),
    ## if the tract is in Guam, the PR, or the USVI, replace with pseudo-code
    ## because these aren't contained in the tract-subcounty crosswalk (but we want to 
    ## retain them)
    geo2010 = case_when(
      state_code %in% c("66", "72", "78") ~ paste0(county_code, "XXXXXX"),
      T ~ geo2010))

rm(hmda_raw)
```

```{r Step 4.5 - Check Income Limits Join}
## Some tracts don't join because of changes over time in tract boundaries
## or because the tract codes are incorrect in the HMDA data. 
## If, however, many are missing income limits data, the process of joining 
## income limits hasn't gone correctly. 
tracts_missing_income_limits = hmda_geo %>%
  left_join(tract_level_income_limits, by = c("geo2010" = "census_tract")) %>%
  filter(
    if_any(.cols = matches("income_limit"), .fn = ~ is.na(.x)),
    !state_code %in% c("66", "72", "78")) %>% ## dropping tracts from Guam / PR / USVI
  ## these don't have tract, so the income limits don't join
  add_count(census_tract) %>%
  distinct(census_tract, .keep_all = T)

if (nrow(tracts_missing_income_limits) > 100) { 
  stop("More than 100 tracts have missing income limits.")}
```


```{r Step 5 - Merge Income Limits and Create Characteristic Flags}
# Merge income limit data and create characteristic flags
# Note that this takes approximately 10 minutes with 2021 data on a laptop
print(paste("Step 5: Merge income limit data and create characteristic flags:", Sys.time()))

hmda_flags <- hmda_geo %>%
    left_join(tract_level_income_limits, by = c("geo2010" = "census_tract")) %>%
    # Imputing with the county mean income limits when there's a valid county code but not a valid tract code
    lazy_dt() %>% #converting to a data.table to take advantage of dtplyr's speed
    group_by(county_code) %>%
    mutate(across(.cols = matches("income_limit"), ~ if_else(is.na(.x), mean(.x, na.rm = T), .x))) %>%
    ungroup() %>%
    ## converting back to a dataframe; dtplyr speed advantage applies to grouped operations
    as_tibble() %>%
    mutate(
      income = income * 1000, #converting to thousands to align with denomination of income limits
      #Income flags
      # flagging income as missing when missing_tract == 1 because these 
      income_missing_flag = if_else(is.na(income) | is.na(county_code), 1, 0), # 
      income_verylow_flag = if_else(income <= income_limit_very_low, 1, 0),
      income_low_flag = if_else(income <= income_limit_low & income > income_limit_very_low, 1, 0),
      income_moderate_flag = if_else(income <= income_limit_moderate & income > income_limit_low, 1, 0),
      income_high_flag = if_else(income > income_limit_moderate, 1, 0), 
      income_available = if_else(income_missing_flag == 0, 1, 0), #Note - this is just the inverse of the income_missing_flag
          
      #Loan type flags
      type_conventional_flag = if_else(loan_type == 1,1,0),
      type_governmentinsured_flag = if_else(loan_type %in% c(2,3,4), 1, 0),
          
      #Loan purpose flags
      purpose_purchase_flag = if_else(loan_purpose == 1,1,0),
      purpose_improvement_flag = if_else(loan_purpose == 2, 1, 0),
      purpose_refinance_flag = if_else(loan_purpose %in% c(31,32), 1, 0),
      purpose_other_flag = if_else(loan_purpose == 4, 1, 0),
          
      #Dwelling count flags
      units_1_4_flag = if_else(derived_dwelling_category %in% c('Single Family (1-4 Units):Site-Built','Single Family (1-4 Units):Manufactured'),1,0),
      units_5ormore_flag = if_else(derived_dwelling_category %in% c('Multifamily:Site-Built','Multifamily:Manufactured'),1,0),
          
      #Outcome flags
      outcome_originated_flag = if_else(action_taken == 1, 1, 0),
      outcome_denied_flag = if_else(action_taken == 3, 1, 0),
      outcome_other_flag = if_else(action_taken %in% c(2,4,5,6,7,8), 1, 0),

      #Lien flag
      lien_firstlien_flag = if_else(lien_status == 1, 1, 0),
      lien_subordinatelien_flag = if_else(lien_status == 2, 1, 0),
          
      #Owner occupancy flag
      occupancy_principal_flag = if_else(occupancy_type == 1, 1, 0),
      occupancy_secondary_flag = if_else(occupancy_type == 2, 1, 0),
      occupancy_investment_flag = if_else(occupancy_type == 3, 1, 0),
      
      #Calculate Race for each applicant and co-applicant separately
      newrace_app = case_when(
        applicant_ethnicity_1 == 1 | applicant_ethnicity_1 %in% 11:14 ~ "Hispanic",
        !is.na(applicant_race_2) ~ "Multiple Races",
        applicant_race_1 %in% 6:7 ~ "Race Not Available",
        is.na(applicant_race_1) ~ "Race Not Available",
        applicant_race_1 == 5 ~ "White",
        applicant_race_1 == 3 ~ "Black",
        applicant_race_1 == 2 | applicant_race_1 %in% 21:27 ~ "Asian",
        applicant_race_1 == 4 | applicant_race_1 %in% 41:44 ~ "Native Hawaiian or Other Pacific Islander",
        applicant_race_1 == 1 ~ "American Indian or Alaskan Native",
        TRUE ~ "NA"),
          
      newrace_coapp = case_when(
        co_applicant_ethnicity_1 == 5 | co_applicant_race_1 == 8 ~ "No co-applicant",
        co_applicant_ethnicity_1 == 1 | co_applicant_ethnicity_1 %in% 11:14 ~ "Hispanic",
        !is.na(co_applicant_race_2) ~ "Multiple Races",
        co_applicant_race_1 %in% 6:7 ~ "Race Not Available",
        is.na(co_applicant_race_1) ~ "Race Not Available",
        co_applicant_race_1 == 5 ~ "White",
        co_applicant_race_1 == 3 ~ "Black",
        co_applicant_race_1 == 2 | co_applicant_race_1 %in% 21:27 ~ "Asian",
        co_applicant_race_1 == 4 | co_applicant_race_1 %in% 41:44 ~ "Native Hawaiian or Other Pacific Islander",
        co_applicant_race_1 == 1 ~ "American Indian or Alaskan Native",
        TRUE ~ "NA"),
          
      #If there is a co-applicant, and neither the applicant's nor co-applicant's race is "Race Not Available", and the co-applicant's race is different from the applicant's race
      hhrace_mixed_flag = if_else(newrace_coapp != "No co-applicant" & newrace_app != "Race Not Available" & newrace_coapp != "Race Not Available" & (newrace_app!=newrace_coapp), 1, 0),

      #Calculate a household race from the applicant and co-applicant race
      hhrace = case_when(
        hhrace_mixed_flag == 1 ~ "Mixed",
        newrace_app == "Hispanic" ~ "Hispanic",
        newrace_app == "Multiple Races" ~ "Multiple Races",
        newrace_app == "White" ~ "White",
        newrace_app == "Black" ~ "Black",
        newrace_app == "Asian" ~ "Asian",
        newrace_app == "Native Hawaiian or Other Pacific Islander" ~ "Native Hawaiian or Other Pacific Islander",
        newrace_app == "American Indian or Alaskan Native" ~ "American Indian or Alaskan Native",
        newrace_app == "Race Not Available" ~ "Race Not Available",
        TRUE ~ "NA"),
          
      #Flags for individual race/ethnicity variables
      race_white_flag = if_else(hhrace == 'White', 1, 0),
      race_black_flag = if_else(hhrace == 'Black', 1, 0),
      race_hispanic_flag = if_else(hhrace == 'Hispanic', 1, 0),
      race_nhpi_flag = if_else(hhrace == 'Native Hawaiian or Other Pacific Islander', 1, 0),
      race_asian_flag = if_else(hhrace == 'Asian', 1, 0),
      race_aian_flag = if_else(hhrace == 'American Indian or Alaskan Native', 1, 0),
      race_multiple_flag = if_else(hhrace == 'Multiple Races', 1, 0),
      race_mixed_flag = if_else(hhrace == 'Mixed', 1, 0),
      race_missing_flag = if_else(hhrace == 'Race Not Available', 1, 0),
          
      #Flag for combined Asian/NHPI race
      race_asian_or_nhpi_flag = if_else(hhrace %in% c('Native Hawaiian or Other Pacific Islander', 'Asian'), 1, 0),
      
      #Race is available denominator
      race_available = if_else(hhrace != 'Race Not Available', 1, 0),
      
      #Specific Asian race flags (NOT filtered by Hispanic)
      race_asian_indian_flag = if_else(applicant_race_1 == 21, 1, 0),
      race_asian_chinese_flag = if_else(applicant_race_1 == 22, 1, 0),
      race_asian_filipino_flag = if_else(applicant_race_1 == 23, 1, 0),
      race_asian_japanese_flag = if_else(applicant_race_1 == 24, 1, 0),
      race_asian_korean_flag = if_else(applicant_race_1 == 25, 1, 0),
      race_asian_vietnamese_flag = if_else(applicant_race_1 == 26, 1, 0),
  
      #Sex flags
      sex_male_flag = if_else(derived_sex =='Male', 1, 0),
      sex_female_flag = if_else(derived_sex =='Female', 1, 0),
      sex_joint_flag = if_else(derived_sex =='Joint', 1, 0),
      #nasex_flag = if_else(derived_sex =='Sex Not Available', 1, 0),
      
      # Sex is available denominator
      sex_available = if_else(derived_sex !='Sex Not Available', 1, 0),
      
      #Sex AND income is available denominator
      sex_income_avail = if_else(sex_available == 1 & income_available == 1, 1, 0),
      
      #Age flags
      across(
        c(applicant_age, co_applicant_age), 
        ~ case_when(
          ## 8888 and 9999 are not defined in the documentation
          ## however, this document: https://www.ffiec.gov/hmda/pdf/2021Guide.pdf
          ## specifies 8888 = Not applicable and 9999 = No co-applicant
          . %in% c("8888", "9999") ~ NA_character_,
          . %in% c("25-34", "35-44") ~ "25-44",
          . %in% c("45-54", "55-64") ~ "45-64",
          . %in% c("65-74", ">74") ~ "65+",
          T ~ .)),
      
      age_older_flag = case_when(
        applicant_age == "65+" & co_applicant_age == "65+" ~ 1,
        applicant_age == "65+" & is.na(co_applicant_age) ~ 1,
        is.na(applicant_age) & co_applicant_age == "65+" ~ 1,
        T ~ 0),
      
      age_middleolder_flag = case_when(
        applicant_age %in% c("45-64") & co_applicant_age %in% c("45-64") ~ 1,
        applicant_age %in% c("45-64") & is.na(co_applicant_age) ~ 1,
        is.na(applicant_age) & co_applicant_age %in% c("45-64") ~ 1,
        T ~ 0),
      
      age_middleyounger_flag = case_when(
        applicant_age %in% c("25-44") & co_applicant_age %in% c("25-44") ~ 1,
        applicant_age %in% c("25-44") & is.na(co_applicant_age) ~ 1,
        is.na(applicant_age) & co_applicant_age %in% c("25-44") ~ 1,
        T ~ 0),

      age_younger_flag = case_when(
        applicant_age == "<25" & co_applicant_age == "<25" ~ 1,
        applicant_age == "<25" & is.na(co_applicant_age) ~ 1,
        is.na(applicant_age) & co_applicant_age == "<25" ~ 1,
        T ~ 0),
    
      age_mixed_flag = if_else(!is.na(applicant_age) & !is.na(co_applicant_age) & (applicant_age != co_applicant_age), 1, 0),
      
      # If either the applicant's or co-applicant's age is available, return 1, else return 0
      age_available = if_else(!is.na(applicant_age) | !is.na(co_applicant_age), 1, 0),
      
      #Standard flag indicating when a record is for the purchase of a principal residence on a first lien of a 1-4 unit residential building with an originated loan 
      standard_flag = if_else(occupancy_principal_flag == 1 & purpose_purchase_flag == 1 & lien_firstlien_flag == 1 & units_1_4_flag == 1 & outcome_originated_flag == 1, 1, 0))

rm(hmda_geo)
```

```{r Step 6 - Create Combined Indicators}
# Create all combined indicators
# Note that this takes approximately X minutes with 2021 data on a laptop
print(paste("Step 6: Create all combined indicators", Sys.time()))

hmda_combined <- hmda_flags %>%
  mutate(
    #Occupancy - investment
    occupancy_investment_origination = rowSums(select(., occupancy_investment_flag, lien_firstlien_flag, outcome_originated_flag) == 1), 
    
    #Occupancy - investment by unit size
    occupancy_investment_units_1_4 = rowSums(select(., occupancy_investment_flag, outcome_originated_flag, lien_firstlien_flag, units_1_4_flag) == 1), 
    occupancy_investment_units_5ormore = rowSums(select(., occupancy_investment_flag, outcome_originated_flag, lien_firstlien_flag, units_5ormore_flag) == 1), 
    
    #Denominators
    income_available = rowSums(select(., income_available, standard_flag) == 1), 
    race_available = rowSums(select(., race_available, standard_flag) == 1), 
    race_income_available = rowSums(select(., race_available, income_available, standard_flag) == 1), 
    age_available = rowSums(select(., age_available, standard_flag) == 1), 
    
    #Owner-occ purchase loans by race
    race_white_purchase = rowSums(select(., race_white_flag, standard_flag) == 1),
    race_black_purchase = rowSums(select(., race_black_flag, standard_flag) == 1),
    race_hispanic_purchase = rowSums(select(., race_hispanic_flag, standard_flag) == 1),
    race_asian_purchase = rowSums(select(., race_asian_flag, standard_flag) == 1),
    race_nhpi_purchase = rowSums(select(., race_nhpi_flag, standard_flag) == 1),
    race_aian_purchase = rowSums(select(., race_aian_flag, standard_flag) == 1),
    race_multiple_purchase = rowSums(select(., race_multiple_flag, standard_flag) == 1), 
    race_mixed_purchase = rowSums(select(., race_mixed_flag, standard_flag) == 1),
    race_missing_purchase = rowSums(select(., race_missing_flag, standard_flag) == 1),
    
    race_asian_or_nhpi_purchase = rowSums(select(., race_asian_or_nhpi_flag, standard_flag) == 1),
    
    #Owner-occ purchase loans by specific race 
    race_asian_indian_purchase = rowSums(select(., race_asian_indian_flag, standard_flag) == 1),
    race_asian_chinese_purchase = rowSums(select(., race_asian_chinese_flag, standard_flag) == 1),
    race_asian_filipino_purchase = rowSums(select(., race_asian_filipino_flag, standard_flag) == 1),
    race_asian_japanese_purchase = rowSums(select(., race_asian_japanese_flag, standard_flag) == 1),
    race_asian_korean_purchase = rowSums(select(., race_asian_korean_flag, standard_flag) == 1),
    race_asian_vietnamese_purchase = rowSums(select(., race_asian_vietnamese_flag, standard_flag) == 1), 
    
    #Owner-occ purchase loans by income
    income_verylow_purchase = rowSums(select(., income_verylow_flag, standard_flag) == 1),
    income_low_purchase = rowSums(select(., income_low_flag, standard_flag) == 1),
    income_moderate_purchase = rowSums(select(., income_moderate_flag, standard_flag) == 1),
    income_high_purchase = rowSums(select(., income_high_flag, standard_flag) == 1),
    income_missing_purchase = rowSums(select(., income_missing_flag, standard_flag) == 1),
    
    #Owner-occ purchase loans to white borrowers by income
    race_white_income_verylow = rowSums(select(., race_white_flag, income_verylow_flag, standard_flag) == 1), 
    race_white_income_low = rowSums(select(., race_white_flag, income_low_flag, standard_flag) == 1),
    race_white_income_moderate = rowSums(select(., race_white_flag, income_moderate_flag, standard_flag) == 1),
    race_white_income_high = rowSums(select(., race_white_flag, income_high_flag, standard_flag) == 1),
    
    #Owner-occ purchaseloans to black borrowers by income
    race_black_income_verylow = rowSums(select(., race_black_flag, income_verylow_flag, standard_flag) == 1),
    race_black_income_low = rowSums(select(., race_black_flag, income_low_flag, standard_flag) == 1),
    race_black_income_moderate = rowSums(select(., race_black_flag, income_moderate_flag, standard_flag) == 1),
    race_black_income_high = rowSums(select(., race_black_flag, income_high_flag, standard_flag) == 1),
    
    #Owner-occ purchase loans to Hispanic borrowers by income
    race_hispanic_income_verylow = rowSums(select(., race_hispanic_flag, income_verylow_flag, standard_flag) == 1),
    race_hispanic_income_low = rowSums(select(., race_hispanic_flag, income_low_flag, standard_flag) == 1),
    race_hispanic_income_moderate = rowSums(select(., race_hispanic_flag, income_moderate_flag, standard_flag) == 1),
    race_hispanic_income_high = rowSums(select(., race_hispanic_flag, income_high_flag, standard_flag) == 1),
    
    #Owner-occ purchase loans to American Indian or Alaskan Native borrowers by income
    race_aian_income_verylow = rowSums(select(., race_aian_flag, income_verylow_flag, standard_flag) == 1),
    race_aian_income_low = rowSums(select(., race_aian_flag, income_low_flag, standard_flag) == 1),
    race_aian_income_moderate = rowSums(select(., race_aian_flag, income_moderate_flag, standard_flag) == 1),
    race_aian_income_high = rowSums(select(., race_aian_flag, income_high_flag, standard_flag) == 1),
    
    #Owner-occ purchase loans to asian, native hawaiian, or pacific islander borrowers by income
    race_asian_or_nhpi_income_verylow = rowSums(select(., race_asian_or_nhpi_flag, income_verylow_flag, standard_flag) == 1),
    race_asian_or_nhpi_income_low = rowSums(select(., race_asian_or_nhpi_flag, income_low_flag, standard_flag) == 1),
    race_asian_or_nhpi_income_moderate = rowSums(select(., race_asian_or_nhpi_flag, income_moderate_flag, standard_flag) == 1),
    race_asian_or_nhpi_income_high = rowSums(select(., race_asian_or_nhpi_flag, income_high_flag, standard_flag) == 1),
    
    #Owner-occ purchase loans to multiple race/ethnicity borrowers by income
    race_multiple_income_verylow = rowSums(select(., race_multiple_flag, income_verylow_flag, standard_flag) == 1),
    race_multiple_income_low = rowSums(select(., race_multiple_flag, income_low_flag, standard_flag) == 1),
    race_multiple_income_moderate = rowSums(select(., race_multiple_flag, income_moderate_flag, standard_flag) == 1),
    race_multiple_income_high = rowSums(select(., race_multiple_flag, income_high_flag, standard_flag) == 1),
    
    #Owner-occ purchase loans to mixed race/ethnicity borrowers by income
    race_mixed_income_verylow = rowSums(select(., race_mixed_flag, income_verylow_flag, standard_flag) == 1),
    race_mixed_income_low = rowSums(select(., race_mixed_flag, income_low_flag, standard_flag) == 1),
    race_mixed_income_moderate = rowSums(select(., race_mixed_flag, income_moderate_flag, standard_flag) == 1),
    race_mixed_income_high = rowSums(select(., race_mixed_flag, income_high_flag, standard_flag) == 1),         
    
    #Owner-occ purchase loans to missing race borrowers by income
    race_missing_income_verylow = rowSums(select(., race_missing_flag, income_verylow_flag, standard_flag) == 1),
    race_missing_income_low = rowSums(select(., race_missing_flag, income_low_flag, standard_flag) == 1),
    race_missing_income_moderate = rowSums(select(., race_missing_flag, income_moderate_flag, standard_flag) == 1),
    race_missing_income_high = rowSums(select(., race_missing_flag, income_high_flag, standard_flag) == 1),
    
    #Owner-occ purchase loans by age
    age_older_purchase = rowSums(select(., age_older_flag, standard_flag) == 1),
    age_middleolder_purchase = rowSums(select(., age_middleolder_flag, standard_flag) == 1),
    age_middleyounger_purchase = rowSums(select(., age_middleyounger_flag, standard_flag) == 1),
    age_younger_purchase = rowSums(select(., age_younger_flag, standard_flag) == 1),
    age_mixed_purchase = rowSums(select(., age_mixed_flag, standard_flag) == 1),
    
    ## the prior lines sum cases where each of the indicators for a flag variable == 1
    ## the lines below evaluate if the sum for each row equals the number of indicators for a given flag variable
    ## if so, the flag variable is set to one. otherwise the flag is set to 0. 
    across(
      ## 2
      .cols = c(income_available, race_available, age_available, race_white_purchase, race_black_purchase, race_hispanic_purchase, race_asian_purchase, 
                race_nhpi_purchase, race_aian_purchase, race_multiple_purchase, race_mixed_purchase, race_missing_purchase, race_asian_or_nhpi_purchase,
                race_asian_indian_purchase, race_asian_chinese_purchase, race_asian_filipino_purchase, race_asian_japanese_purchase, race_asian_korean_purchase, 
                race_asian_vietnamese_purchase, income_verylow_purchase, income_low_purchase, income_moderate_purchase, income_high_purchase, income_missing_purchase,
                age_older_purchase, age_middleolder_purchase, age_middleyounger_purchase, age_younger_purchase, age_mixed_purchase),
      ~ if_else(.x == 2, 1, 0)),
    across(
      .cols = c(occupancy_investment_origination, race_income_available, race_white_income_verylow, race_white_income_low, race_white_income_moderate, race_white_income_high, 
                race_black_income_verylow, race_black_income_low, race_black_income_moderate, race_black_income_high, race_hispanic_income_verylow, race_hispanic_income_low, race_hispanic_income_moderate,
                race_hispanic_income_high, race_aian_income_verylow, race_aian_income_low, race_aian_income_moderate, race_hispanic_income_high, race_aian_income_verylow,
                race_aian_income_low, race_aian_income_moderate, race_aian_income_high, race_asian_or_nhpi_income_verylow, race_asian_or_nhpi_income_low, race_asian_or_nhpi_income_moderate,
                race_asian_or_nhpi_income_high, race_multiple_income_verylow, race_multiple_income_low, race_multiple_income_moderate, race_multiple_income_high, race_mixed_income_verylow,
                race_mixed_income_low, race_mixed_income_moderate, race_mixed_income_high, race_missing_income_verylow, race_missing_income_low, race_missing_income_moderate, race_missing_income_high),
      ~ if_else(.x == 3, 1, 0)),
    across(
      .cols = c(occupancy_investment_units_1_4, occupancy_investment_units_5ormore),
      ~ if_else(.x == 4, 1, 0)),
    
    #Medians for owner-occ purchase loans
    #Note: these aren't median values -- these are summarized to tract-level medians in a subsequent step
    income_median = if_else(standard_flag == 1, income, NA_real_), 
    owner_loan_amount_median = if_else(standard_flag == 1, loan_amount, NA_real_)) %>%
  rename(owner_purchase_originations = standard_flag)
```

```{r Step 7 - Summarize to Tract}
# Summarize by tract 
# Note that this takes approximately X minutes with 2021 data on a laptop
print(paste("Step 7: Summarize final variables to the tract level", Sys.time()))

#List of sum variables to include in the final file
final_vars <- c(
  "owner_purchase_originations", #owner-occupied, first-lien home purchases of 1-4 unit dwellings
  
  #Investment vars
  "occupancy_investment_origination", "occupancy_investment_units_1_4", "occupancy_investment_units_5ormore",
  
  #Denominator vars
  "income_available", "race_available", "race_income_available", "age_available",
                
  #Race/ethnicity vars
  "race_white_purchase", "race_black_purchase", "race_hispanic_purchase", "race_asian_purchase", "race_nhpi_purchase", "race_asian_or_nhpi_purchase", "race_multiple_purchase",
  "race_missing_purchase",  "race_mixed_purchase", "race_aian_purchase", "race_asian_indian_purchase", "race_asian_chinese_purchase",
  "race_asian_filipino_purchase", "race_asian_japanese_purchase", "race_asian_korean_purchase", "race_asian_vietnamese_purchase",
                
  #Income vars
  "income_verylow_purchase","income_low_purchase","income_moderate_purchase","income_high_purchase",
                
  #Combined race/income vars
  "race_white_income_verylow","race_white_income_low","race_white_income_moderate","race_white_income_high",
  "race_black_income_verylow","race_black_income_low","race_black_income_moderate","race_black_income_high",
  "race_hispanic_income_verylow","race_hispanic_income_low","race_hispanic_income_moderate","race_hispanic_income_high",
  "race_aian_income_verylow","race_aian_income_low","race_aian_income_moderate","race_aian_income_high",
  "race_asian_or_nhpi_income_verylow","race_asian_or_nhpi_income_low","race_asian_or_nhpi_income_moderate","race_asian_or_nhpi_income_high",
  "race_multiple_income_verylow","race_multiple_income_low","race_multiple_income_moderate","race_multiple_income_high",
  "race_mixed_income_verylow","race_mixed_income_low","race_mixed_income_moderate","race_mixed_income_high",
  "race_missing_income_verylow","race_missing_income_low","race_missing_income_moderate","race_missing_income_high",
  
  #Age vars
  "age_older_purchase", "age_middleolder_purchase", "age_middleyounger_purchase", "age_younger_purchase", "age_mixed_purchase",
  
  #Missing vars
  "missing_tract")

hmda_tract <- hmda_combined %>%
  ## converting to a data.table to take advantage of dtplyr's speed, which is 
  ## particularly significant for this group_by %>% summarise workflow
  ## (dtplyr does not bring significant performance advantages for the steps above)
  lazy_dt() %>%
  group_by(geo2010) %>% 
  summarise(
    across(all_of(final_vars), sum, na.rm = TRUE),
    across(matches("median"), median, na.rm = TRUE)) %>% 
  left_join(
    ## joining ACS variables to the HMDA data
    acs_housing %>%
      mutate(
        #Percent owner-occupied units (ACS)
        occupancy_owneroccupied_percent = (housing_units_occupied_owner / housing_units_occupied_total) %>% round(digits = 2)) %>%
      select(
        GEOID, 
        occupancy_unitsoccupied_count = housing_units_occupied_total,
        occupancy_owneroccupied_count = housing_units_occupied_owner,
        occupancy_owneroccupied_percent),
    by = c("geo2010" = "GEOID")) %>%
  rename(missing_geo = missing_tract) %>% 
  arrange(geo2010) 
```

```{r Step 8 - Final Cleanup and Quality Checks}
#Final cleanup
print(paste("Step 8: cleanup", Sys.time()))

hmda_final <- hmda_tract %>%
  mutate(invalid_geo = if_else(missing_geo > 0, 1, 0)) %>%
  select(-missing_geo) %>% 
  ## converting from a data.table back to a tibble
  as_tibble()

## check to ensure all variables have non-zero values in some tracts
#skimr::fix_windows_histograms() ## if histograms do not render correctly, use this function and re-run
skimr::skim(hmda_final)

## this should return a dataframe with no rows
failed_quality_checks = hmda_final %>%
  mutate(
    # creating variables reflecting the sum across each component variable within
    # each domain (age, income, race, race_income). these "check" variables should equal
    # the corresponding [domain]_available variable.
    age_check = rowSums(across(c(matches("age"), -matches("available"))), na.rm = T), 
    income_check = rowSums(across(c(matches("income"), -matches("race|median|available"))), na.rm = T),
    race_check = rowSums(across(
      c(race_white_purchase, race_black_purchase, race_hispanic_purchase, race_asian_or_nhpi_purchase, 
        race_multiple_purchase, race_mixed_purchase, race_aian_purchase)), na.rm = T),
    race_income_check = rowSums(across(c(matches("race.*income"), -matches("available|missing"))), na.rm = T),
    # all tract IDs should be 11 characters
    tract_id_characters = nchar(geo2010),
    errors = case_when(
      age_check != age_available ~ "age check failed",
      income_check != income_available ~ "income check failed",
      race_check != race_available ~ "race check failed",
      race_income_check != race_income_available ~ "race-income check failed",
      tract_id_characters != 11 ~ "invalid tract id",
      T ~ NA_character_)) %>%
  filter(!is.na(errors)) %>%
  select(errors, tract_id_characters, income_available, income_check,  matches("income"), -matches("race"), geo2010)

## reading in the codebook
codebook = readxl::read_xlsx(codebook_path, sheet = 2)

## check to ensure that there aren't any variables in the codebook
## that aren't in the final dataset. this should return a dataframe with no rows.
codebook_variables_missing_from_dataset = codebook %>%
  filter(!(`Name - 2021` %in% (colnames(hmda_final))))

## check to ensure there aren't any columns in the codebook
## that aren't in the final dataset. this should return an empty character vector.
dataset_variables_missing_from_codebook = colnames(hmda_final)[!(colnames(hmda_final) %in% codebook$`Name - 2021`)]

if ( (nrow(failed_quality_checks) > 0) |  (nrow(codebook_variables_missing_from_dataset) > 0) | (length(dataset_variables_missing_from_codebook) > 0) ) { 
  warning("Not all quality checks passed!") } else { 
    warning("All quality checks passed!") }

## Lastly, rename the census tract variable to distinguish between 2010-vintage
## tracts and 2020-vintage tracts
hmda_final = hmda_final %>%
  { if (as.numeric(year) > 2021) rename(., geo2020 = geo2010) else . }
```

```{r Step 9 - Export Data}
#Export final CSV
print(paste("Step 9: Export CSV", Sys.time()))

write_csv(hmda_final, output_path)

#End time for log
endtime <- Sys.time()
totaltime <- endtime - starttime
print(paste("End Time:", endtime))
print(paste("Total Run Time:", totaltime))

#End of program
```