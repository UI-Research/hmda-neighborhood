---
title: "NationalHMDA_TractSummaryIndicators"
output: html_document
date: '2022-09-14'
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = F,
  include = T,
  eval = T,
  message = F,
  warning = F
)
```

```{r libraries}
library(tidyverse)
library(here)
library(skimr)
library(arrow)
```

```{r metadata}
#Update this value to the appropriate year
year = "2021"

#Relative path to the raw HMDA dataset (.parquet) - ~1.1 GB
hmda_path = here("data-raw") %>% list.files(full.names = T) %>% str_match(paste0(".*", year, ".*\\.parquet")) %>% .[!is.na(.)] 

#Data source: https://www.huduser.gov/portal/datasets/il/il21/Section8-FY21.xlsx
#Path to income limit data (csv):
income_limits_path <- here("data-raw", "income-limits", "Section8-FY21.csv")

#Path to codebook (.xlsx)
codebook_path = here("Urban-HMDA_neighborhood_data_codebook_external.xlsx")

#Path to write final dataset (csv)
output_path = here("data-final", paste0("hmda_tract_", year, ".csv"))

if ( !file.exists(hmda_path) ) { stop(paste0("There is no HMDA data file at the designated path: ", hmda_path)) }
if ( !file.exists(income_limits_path) ) { stop(paste0("There is no income limits data file at the designated path: ", income_limits_path)) }
if ( !file.exists(codebook_path) ) { stop(paste0("There is no codebook at the designated path: ", codebook_path)) }
```

```{r read data, cache = F}
# Read national file and add county code
starttime <- Sys.time()
print(paste("Start Time", starttime))
print(paste("Step 1: Read national file and add county code", Sys.time()))

#The relevant income limits columns
income_limits_columns = c(
  "State",
  "County",
  "l50_4",
  "l80_4"
)

#The relevant HMDA columns
hmda_columns = c(
  "state_code",
  "county_code",
  "census_tract",
  "income",
  "loan_type",
  "loan_amount",
  "loan_purpose",
  "derived_dwelling_category",
  "action_taken",
  "lien_status",
  "occupancy_type",
  "applicant_ethnicity_1",
  "co_applicant_race_2",
  "co_applicant_ethnicity_1",
  "applicant_race_1",
  "co_applicant_race_1",
  "applicant_race_2",
  "derived_sex",
  "applicant_age",
  "co_applicant_age",
  "purchaser_type"
  )

#Reading the HMDA parquet file
#Only reading in the needed columns to limit file size
hmda_raw <- read_parquet(file = hmda_path, col_select = all_of(hmda_columns)) %>%
    mutate(
      #If the census tract is coded as "na" then switch to proper missing
      census_tract = case_when(
        census_tract %in% c("na", "nA") ~ as.character(NA), 
        TRUE ~ as.character(census_tract)),
      
      #If the county is coded as "na" or "99999" then switch to proper missing
      county_code = case_when(
        county_code %in% c("na","N/AN/", "nA", "99999") ~ as.character(NA), 
        TRUE ~ as.character(county_code)),
      
      #Check the state part of the county code
      ust = substr(county_code, 1, 2),
      
      #Create ucounty from the county_code var if the state part is valid; 00, 03, 07 and 80 are not state FIPS codes
      ucounty = case_when(
        ust %in% c("00","03","07","80") ~ as.character(NA), 
        TRUE ~ as.character(county_code)))

# Read income limits file and define max limits for each county
print(paste("Step 2: Read income limits file and define max limits for each county", Sys.time()))

income_limits_raw <- read_csv(income_limits_path) %>%
  select(all_of(income_limits_columns)) %>%
  mutate(
    #Create padded state FIPs code
    st_in = str_pad(State, 2, pad = "0"),
    #Created padded county code
    cnt_in = str_pad(County, 3, pad = "0"),
    #Create combined state + county code
    ucounty = paste0(st_in, cnt_in),
    #Very low income max (Under 50% AMI)
    income_limit_very_low = l50_4, 
    #Low income max (50-80% AMI)
    income_limit_low = l80_4,
    #Medium income max (80-100% AMI)
    income_limit_moderate = (l80_4 / .8) * 1.2) %>% 
    #Keep unique counties
    distinct(ucounty, .keep_all = TRUE) 

# Load state and county codes using {tigris} package
print(paste("Step 3: Load state and county codes from {tigris}", Sys.time()))

# Reading in state and county codes
states_tigris <- tigris::fips_codes %>%
  # Creating a combined state + county code for joining purposes
  unite(ucounty, state_code, county_code, sep = "", remove = F) %>%
  # Dropping unneeded columns
  select(-c(state_name, county))

codebook = readxl::read_xlsx(codebook_path, sheet = 2)
```

```{r acs housing variables}
## Note: 2021 HMDA data use 2010 census tract definitions, per this source:
## consumerfinance.gov/data-research/hmda/summary-of-201-data-on-mortgage-lending

#Path to locally-saved ACS data
acs_file_path = here("data-raw", "acs_5yr_2019_owner_occupied_housing.csv")

#If data is saved locally, then read in from the local path
#Otherwise, use the {tidycensus} package to query the Census API
if (file.exists(acs_file_path)) {
  
  acs_housing = read_csv(acs_file_path)

  } else {
  
  # Variable codes for Census query
  acs_vars = c(
    "B25003_001", #total occupied housing units
    "B25003_002" #owner-occupied units
  )
  
  #Year to pull Census data -- using pre-2020 data so that tract geometries align with
  #the tract geometries used for the raw HMDA data
  census_year = 2019
  
  #Map over all states and return 5-year ACS data for the year and variables
  #defined above
  acs_housing = map_dfr(
    datasets::state.abb,
    ~ tidycensus::get_acs(
        state = .,
        variables = acs_vars,
        year = census_year,
        geography = "tract",
        survey = "acs5",
        output = "wide")) %>%
   #Retain the GEOID and estimates for each queried variable
    select(GEOID, housing_units_occupied_total = B25003_001E, housing_units_occupied_owner = B25003_002E)
  
  #Write the data to the local path so that it's not neccesarry to query the API in the future
  write_csv(acs_housing, here("data-raw", "acs_5yr_2019_owner_occupied_housing.csv"))
  }
```

```{r merge data}
# Merge national file state codes
print(paste("Step 4: Merge national file state codes", Sys.time()))

# Join state and county codes
hmda_states <- left_join(hmda_raw, states_tigris, by = c("state_code", "county_code", "ucounty"))

# Merge national file and counties, flag and create dummy codes for missing tracts/counties
print(paste("Step 5: Merge national file and counties, flag and create dummy codes for missing tracts/counties", Sys.time()))

hmda_geo <- hmda_states %>%
  mutate(
    # Derive ucounty from census_tract when the first is missing and the second is not
    ucounty = case_when(
      is.na(ucounty) & !is.na(census_tract) & (str_sub(as.character(census_tract), 1, 5) %in% states_tigris$ucounty) ~ str_sub(as.character(census_tract), 1, 5),
      T ~ ucounty
    ),
    
    #Create flag variables for when the tract or county codes are missing
    missing_tract = case_when(is.na(census_tract) ~ 1, TRUE ~ 0), 

    missing_county = case_when(is.na(ucounty) ~ 1, TRUE ~ 0),
    geo2010 = case_when(
      #If Census tract is valid then geo2010 is the input census tract
      missing_tract == 0 ~ as.character(census_tract),
      
      #If the tract is missing but the county is valid then code as state + county + 000000
      missing_tract == 1 & missing_county == 0 ~ as.character(paste0(ucounty, "000000")),
      
      #If the tract and county are missing then code as state + 000000000
      missing_tract == 1 & missing_county == 1 & !is.na(state_code) ~ as.character(paste0(state_code, "000000000")),
      
      #If the geography is completely invalid, use 99999999999
      TRUE ~ "99999999999"))

# Merge income limit data and create characteristic flags
print(paste("Step 6: Merge income limit data and create characteristic flags", Sys.time()))

hmda_flags <- left_join(hmda_geo, income_limits_raw, by = "ucounty") %>%
    mutate(
      income = income * 1000, #converting to thousands to align with denomination of income limits
      
      #Income flags
      # flagging income as missing when ucounty is missing because ucounty is the join key for the income limits; income values may still be present in these cases
      income_missing_flag = if_else(is.na(income) | is.na(ucounty), 1, 0), 
      income_verylow_flag = if_else(income <= income_limit_very_low, 1, 0),
      income_low_flag = if_else(income <= income_limit_low & income > income_limit_very_low, 1, 0),
      income_moderate_flag = if_else(income <= income_limit_moderate & income > income_limit_low, 1, 0),
      income_high_flag = if_else(income > income_limit_moderate, 1, 0), ## this is the old code, which looks incorrect: if_else(moderate <= income, 1, 0),
      income_available = if_else(income_missing_flag == 0, 1, 0), #Note - this is just the inverse of the income_missing_flag
          
      #Loan type flags
      type_conventional_flag = if_else(loan_type == 1,1,0),
      type_governmentinsured_flag = if_else(loan_type %in% c(2,3,4), 1, 0),
          
      #Loan purpose flags
      purpose_purchase_flag = if_else(loan_purpose == 1,1,0),
      purpose_improvement_flag = if_else(loan_purpose == 2, 1, 0),
      purpose_refinance_flag = if_else(loan_purpose %in% c(31,32), 1, 0),
      purpose_other_flag = if_else(loan_purpose == 4, 1, 0),
          
      #Dwelling count flags
      units_1_4_flag = if_else(derived_dwelling_category %in% c('Single Family (1-4 Units):Site-Built','Single Family (1-4 Units):Manufactured'),1,0),
      units_5ormore_flag = if_else(derived_dwelling_category %in% c('Multifamily:Site-Built','Multifamily:Manufactured'),1,0),
          
      #Outcome flags
      #app_flag = 1,
      outcome_originated_flag = if_else(action_taken == 1, 1, 0),
      outcome_denied_flag = if_else(action_taken == 3, 1, 0),
      outcome_other_flag = if_else(action_taken %in% c(2,4,5,6,7,8), 1, 0),

      #Lien flag
      lien_firstlien_flag = if_else(lien_status == 1, 1, 0),
      lien_subordinatelien_flag = if_else(lien_status == 2, 1, 0),
          
      #Owner occupancy flag
      occupancy_principal_flag = if_else(occupancy_type == 1, 1, 0),
      occupancy_secondary_flag = if_else(occupancy_type == 2, 1, 0),
      occupancy_investment_flag = if_else(occupancy_type == 3, 1, 0),
      
      #Calculate Race for each applicant and co-applicant separately
      newrace_app = case_when(
        applicant_ethnicity_1 == 1 | applicant_ethnicity_1 %in% 11:14 ~ "Hispanic",
        !is.na(applicant_race_2) ~ "Multiple Races",
        applicant_race_1 %in% 6:7 ~ "Race Not Available",
        is.na(applicant_race_1) ~ "Race Not Available",
        applicant_race_1 == 5 ~ "White",
        applicant_race_1 == 3 ~ "Black",
        applicant_race_1 == 2 | applicant_race_1 %in% 21:27 ~ "Asian",
        applicant_race_1 == 4 | applicant_race_1 %in% 41:44 ~ "Native Hawaiian or Other Pacific Islander",
        applicant_race_1 == 1 ~ "American Indian or Alaskan Native",
        TRUE ~ "NA"),
          
      newrace_coapp = case_when(
        co_applicant_ethnicity_1 == 5 | co_applicant_race_1 == 8 ~ "No co-applicant",
        co_applicant_ethnicity_1 == 1 | co_applicant_ethnicity_1 %in% 11:14 ~ "Hispanic",
        !is.na(co_applicant_race_2) ~ "Multiple Races",
        co_applicant_race_1 %in% 6:7 ~ "Race Not Available",
        is.na(co_applicant_race_1) ~ "Race Not Available",
        co_applicant_race_1 == 5 ~ "White",
        co_applicant_race_1 == 3 ~ "Black",
        co_applicant_race_1 == 2 | co_applicant_race_1 %in% 21:27 ~ "Asian",
        co_applicant_race_1 == 4 | co_applicant_race_1 %in% 41:44 ~ "Native Hawaiian or Other Pacific Islander",
        co_applicant_race_1 == 1 ~ "American Indian or Alaskan Native",
        TRUE ~ "NA"),
          
      #If there is a co-applicant, and neither the applicant's nor co-applicant's race is "Race Not Available", and the co-applicant's race is different from the applicant's race
      hhrace_mixed_flag = if_else(newrace_coapp != "No co-applicant" & newrace_app != "Race Not Available" & newrace_coapp != "Race Not Available" & (newrace_app!=newrace_coapp), 1, 0),

      #Calculate a household race from the applicant and co-applicant race
      hhrace = case_when(
        hhrace_mixed_flag == 1 ~ "Mixed",
        newrace_app == "Hispanic" ~ "Hispanic",
        newrace_app == "Multiple Races" ~ "Multiple Races",
        newrace_app == "White" ~ "White",
        newrace_app == "Black" ~ "Black",
        newrace_app == "Asian" ~ "Asian",
        newrace_app == "Native Hawaiian or Other Pacific Islander" ~ "Native Hawaiian or Other Pacific Islander",
        newrace_app == "American Indian or Alaskan Native" ~ "American Indian or Alaskan Native",
        newrace_app == "Race Not Available" ~ "Race Not Available",
        TRUE ~ "NA"),
          
      #Flags for individual race/ethnicity variables
      race_white_flag = if_else(hhrace == 'White', 1, 0),
      race_black_flag = if_else(hhrace == 'Black', 1, 0),
      race_hispanic_flag = if_else(hhrace == 'Hispanic', 1, 0),
      race_nhpi_flag = if_else(hhrace == 'Native Hawaiian or Other Pacific Islander', 1, 0),
      race_asian_flag = if_else(hhrace == 'Asian', 1, 0),
      race_aian_flag = if_else(hhrace == 'American Indian or Alaskan Native', 1, 0),
      race_multiple_flag = if_else(hhrace == 'Multiple Races', 1, 0),
      race_mixed_flag = if_else(hhrace == 'Mixed', 1, 0),
      race_missing_flag = if_else(hhrace == 'Race Not Available', 1, 0),
          
      #Flag for combined Asian/NHPI race
      race_asian_or_nhpi_flag = if_else(hhrace %in% c('Native Hawaiian or Other Pacific Islander', 'Asian'), 1, 0),
      
      #Race is available denominator
      race_available = if_else(hhrace != 'Race Not Available', 1, 0),
      
      #Specific Asian race flags (NOT filtered by Hispanic)
      race_asian_indian_flag = if_else(applicant_race_1 == 21, 1, 0),
      race_asian_chinese_flag = if_else(applicant_race_1 == 22, 1, 0),
      race_asian_filipino_flag = if_else(applicant_race_1 == 23, 1, 0),
      race_asian_japanese_flag = if_else(applicant_race_1 == 24, 1, 0),
      race_asian_korean_flag = if_else(applicant_race_1 == 25, 1, 0),
      race_asian_vietnamese_flag = if_else(applicant_race_1 == 26, 1, 0),
  
      #Sex flags
      sex_male_flag = if_else(derived_sex =='Male', 1, 0),
      sex_female_flag = if_else(derived_sex =='Female', 1, 0),
      sex_joint_flag = if_else(derived_sex =='Joint', 1, 0),
      #nasex_flag = if_else(derived_sex =='Sex Not Available', 1, 0),
      
      # Sex is available denominator
      sex_available = if_else(derived_sex !='Sex Not Available', 1, 0),
      
      #Sex AND income is available denominator
      sex_income_avail = if_else(sex_available == 1 & income_available == 1, 1, 0),
      
      #Age flags
      across(
        c(applicant_age, co_applicant_age), 
        ~ case_when(
          ## 8888 and 9999 are not defined in the documentation
          ## however, this document: https://www.ffiec.gov/hmda/pdf/2021Guide.pdf
          ## specifies 8888 = Not applicable and 9999 = No co-applicant
          . %in% c("8888", "9999") ~ NA_character_,
          . %in% c("25-34", "35-44") ~ "25-44",
          . %in% c("45-54", "55-64") ~ "45-64",
          . %in% c("65-74", ">74") ~ "65+",
          T ~ .
        )),
      
      age_older_flag = case_when(
        applicant_age == "65+" & co_applicant_age == "65+" ~ 1,
        applicant_age == "65+" & is.na(co_applicant_age) ~ 1,
        is.na(applicant_age) & co_applicant_age == "65+" ~ 1,
        T ~ 0),
      
      age_middleolder_flag = case_when(
        applicant_age %in% c("45-64") & co_applicant_age %in% c("45-64") ~ 1,
        applicant_age %in% c("45-64") & is.na(co_applicant_age) ~ 1,
        is.na(applicant_age) & co_applicant_age %in% c("45-64") ~ 1,
        T ~ 0),
      
      age_middleyounger_flag = case_when(
        applicant_age %in% c("25-44") & co_applicant_age %in% c("25-44") ~ 1,
        applicant_age %in% c("25-44") & is.na(co_applicant_age) ~ 1,
        is.na(applicant_age) & co_applicant_age %in% c("25-44") ~ 1,
        T ~ 0),

      age_younger_flag = case_when(
        applicant_age == "<25" & co_applicant_age == "<25" ~ 1,
        applicant_age == "<25" & is.na(co_applicant_age) ~ 1,
        is.na(applicant_age) & co_applicant_age == "<25" ~ 1,
        T ~ 0),
    
      age_mixed_flag = if_else(!is.na(applicant_age) & !is.na(co_applicant_age) & (applicant_age != co_applicant_age), 1, 0),
      
      # If either the applicant's or co-applicant's age is available, return 1, else return 0
      age_available = if_else(!is.na(applicant_age) | !is.na(co_applicant_age), 1, 0),
      
      #Standard flag indicating when a record is for the purchase of a principal residence on a first lien of a 1-4 unit residential building with an originated loan 
      standard_flag = if_else(occupancy_principal_flag == 1 & purpose_purchase_flag == 1 & lien_firstlien_flag == 1 & units_1_4_flag == 1 & outcome_originated_flag == 1, 1, 0)
    )

```

```{r developing final indicators}
rm(hmda_raw)
rm(hmda_states)
rm(hmda_geo)

# This function creates final variables by taking any flag variables that are input
# and checking that all conditions are equal to one
create_var <- function(...){
  if_else(all(c(...) == 1), 1, 0)
}

# Create all combined indicators
print(paste("Step 7: Create all combined indicators", Sys.time()))

hmda_combined1 <- hmda_flags %>%
  mutate(
    #Occupancy - investment
    occupancy_investment_origination = pmap_dbl(list(occupancy_investment_flag, lien_firstlien_flag, outcome_originated_flag), ~ create_var(c(...))),
    
    #Occupancy - investment by unit size
    occupancy_investment_units_1_4 = pmap_dbl(list(occupancy_investment_flag, outcome_originated_flag, lien_firstlien_flag, units_1_4_flag), ~ create_var(c(...))),
    occupancy_investment_units_5ormore = pmap_dbl(list(occupancy_investment_flag, outcome_originated_flag, lien_firstlien_flag, units_5ormore_flag), ~ create_var(c(...))),
    
    #Denominators
    income_available = pmap_dbl(list(income_available, standard_flag), ~ create_var(c(...))),
    race_available = pmap_dbl(list(race_available, standard_flag), ~ create_var(c(...))),
    race_income_available = pmap_dbl(list(race_available, income_available, standard_flag), ~ create_var(c(...))),
    age_available = pmap_dbl(list(age_available, standard_flag), ~ create_var(c(...))),
    
    #Owner-occ purchase loans by race
    race_white_purchase = pmap_dbl(list(race_white_flag, standard_flag), ~ create_var(c(...))),
    race_black_purchase = pmap_dbl(list(race_black_flag, standard_flag), ~ create_var(c(...))),
    race_hispanic_purchase = pmap_dbl(list(race_hispanic_flag, standard_flag), ~ create_var(c(...))),
    race_asian_purchase = pmap_dbl(list(race_asian_flag, standard_flag), ~ create_var(c(...))),
    race_nhpi_purchase = pmap_dbl(list(race_nhpi_flag, standard_flag), ~ create_var(c(...))),
    race_aian_purchase = pmap_dbl(list(race_aian_flag, standard_flag), ~ create_var(c(...))),
    race_multiple_purchase = pmap_dbl(list(race_multiple_flag, standard_flag), ~ create_var(c(...))), 
    race_mixed_purchase = pmap_dbl(list(race_mixed_flag, standard_flag), ~ create_var(c(...))),
    race_missing_purchase = pmap_dbl(list(race_missing_flag, standard_flag), ~ create_var(c(...))),
    
    race_asian_or_nhpi_purchase = pmap_dbl(list(race_asian_or_nhpi_flag, standard_flag), ~ create_var(c(...))),
    
    #Owner-occ purchase loans by specific race 
    race_asian_indian_purchase = pmap_dbl(list(race_asian_indian_flag, standard_flag), ~ create_var(c(...))),
    race_asian_chinese_purchase = pmap_dbl(list(race_asian_chinese_flag, standard_flag), ~ create_var(c(...))),
    race_asian_filipino_purchase = pmap_dbl(list(race_asian_filipino_flag, standard_flag), ~ create_var(c(...))),
    race_asian_japanese_purchase = pmap_dbl(list(race_asian_japanese_flag, standard_flag), ~ create_var(c(...))),
    race_asian_korean_purchase = pmap_dbl(list(race_asian_korean_flag, standard_flag), ~ create_var(c(...))),
    race_asian_vietnamese_purchase = pmap_dbl(list(race_asian_vietnamese_flag, standard_flag), ~ create_var(c(...))))

hmda_combined2 <- hmda_combined1 %>%
  mutate(        
    #Owner-occ purchase loans by income
    income_verylow_purchase = pmap_dbl(list(income_verylow_flag, standard_flag), ~ create_var(c(...))),
    income_low_purchase = pmap_dbl(list(income_low_flag, standard_flag), ~ create_var(c(...))),
    income_moderate_purchase = pmap_dbl(list(income_moderate_flag, standard_flag), ~ create_var(c(...))),
    income_high_purchase = pmap_dbl(list(income_high_flag, standard_flag), ~ create_var(c(...))),
    income_missing_purchase = pmap_dbl(list(income_missing_flag, standard_flag), ~ create_var(c(...))),
    
    #Owner-occ purchase loans to white borrowers by income
    race_white_income_verylow = pmap_dbl(list(race_white_flag, income_verylow_flag, standard_flag), ~ create_var(c(...))),
    race_white_income_low = pmap_dbl(list(race_white_flag, income_low_flag, standard_flag), ~ create_var(c(...))),
    race_white_income_moderate = pmap_dbl(list(race_white_flag, income_moderate_flag, standard_flag), ~ create_var(c(...))),
    race_white_income_high = pmap_dbl(list(race_white_flag, income_high_flag, standard_flag), ~ create_var(c(...))),
    
    #Owner-occ purchaseloans to black borrowers by income
    race_black_income_verylow = pmap_dbl(list(race_black_flag, income_verylow_flag, standard_flag), ~ create_var(c(...))),
    race_black_income_low = pmap_dbl(list(race_black_flag, income_low_flag, standard_flag), ~ create_var(c(...))),
    race_black_income_moderate = pmap_dbl(list(race_black_flag, income_moderate_flag, standard_flag), ~ create_var(c(...))),
    race_black_income_high = pmap_dbl(list(race_black_flag, income_high_flag, standard_flag), ~ create_var(c(...))),
    
    #Owner-occ purchase loans to Hispanic borrowers by income
    race_hispanic_income_verylow = pmap_dbl(list(race_hispanic_flag, income_verylow_flag, standard_flag), ~ create_var(c(...))),
    race_hispanic_income_low = pmap_dbl(list(race_hispanic_flag, income_low_flag, standard_flag), ~ create_var(c(...))),
    race_hispanic_income_moderate = pmap_dbl(list(race_hispanic_flag, income_moderate_flag, standard_flag), ~ create_var(c(...))),
    race_hispanic_income_high = pmap_dbl(list(race_hispanic_flag, income_high_flag, standard_flag), ~ create_var(c(...))),
    
    #Owner-occ purchase loans to American Indian or Alaskan Native borrowers by income
    race_aian_income_verylow = pmap_dbl(list(race_aian_flag, income_verylow_flag, standard_flag), ~ create_var(c(...))),
    race_aian_income_low = pmap_dbl(list(race_aian_flag, income_low_flag, standard_flag), ~ create_var(c(...))),
    race_aian_income_moderate = pmap_dbl(list(race_aian_flag, income_moderate_flag, standard_flag), ~ create_var(c(...))),
    race_aian_income_high = pmap_dbl(list(race_aian_flag, income_high_flag, standard_flag), ~ create_var(c(...))),
    
    #Owner-occ purchase loans to asian, native hawaiian, or pacific islander borrowers by income
    race_asian_or_nhpi_income_verylow = pmap_dbl(list(race_asian_or_nhpi_flag, income_verylow_flag, standard_flag), ~ create_var(c(...))),
    race_asian_or_nhpi_income_low = pmap_dbl(list(race_asian_or_nhpi_flag, income_low_flag, standard_flag), ~ create_var(c(...))),
    race_asian_or_nhpi_income_moderate = pmap_dbl(list(race_asian_or_nhpi_flag, income_moderate_flag, standard_flag), ~ create_var(c(...))),
    race_asian_or_nhpi_income_high = pmap_dbl(list(race_asian_or_nhpi_flag, income_high_flag, standard_flag), ~ create_var(c(...))),
    
    #Owner-occ purchase loans to multiple race/ethnicity borrowers by income
    race_multiple_income_verylow = pmap_dbl(list(race_multiple_flag, income_verylow_flag, standard_flag), ~ create_var(c(...))),
    race_multiple_income_low = pmap_dbl(list(race_multiple_flag, income_low_flag, standard_flag), ~ create_var(c(...))),
    race_multiple_income_moderate = pmap_dbl(list(race_multiple_flag, income_moderate_flag, standard_flag), ~ create_var(c(...))),
    race_multiple_income_high = pmap_dbl(list(race_multiple_flag, income_high_flag, standard_flag), ~ create_var(c(...))),
    
    #Owner-occ purchase loans to mixed race/ethnicity borrowers by income
    race_mixed_income_verylow = pmap_dbl(list(race_mixed_flag, income_verylow_flag, standard_flag), ~ create_var(c(...))),
    race_mixed_income_low = pmap_dbl(list(race_mixed_flag, income_low_flag, standard_flag), ~ create_var(c(...))),
    race_mixed_income_moderate = pmap_dbl(list(race_mixed_flag, income_moderate_flag, standard_flag), ~ create_var(c(...))),
    race_mixed_income_high = pmap_dbl(list(race_mixed_flag, income_high_flag, standard_flag), ~ create_var(c(...))),         
    
    #Owner-occ purchase loans to missing race borrowers by income
    race_missing_income_verylow = pmap_dbl(list(race_missing_flag, income_verylow_flag, standard_flag), ~ create_var(c(...))),
    race_missing_income_low = pmap_dbl(list(race_missing_flag, income_low_flag, standard_flag), ~ create_var(c(...))),
    race_missing_income_moderate = pmap_dbl(list(race_missing_flag, income_moderate_flag, standard_flag), ~ create_var(c(...))),
    race_missing_income_high = pmap_dbl(list(race_missing_flag, income_high_flag, standard_flag), ~ create_var(c(...))),
    
    #Owner-occ purchase loans by age
    age_older_purchase = pmap_dbl(list(age_older_flag, standard_flag), ~ create_var(c(...))),
    age_middleolder_purchase = pmap_dbl(list(age_middleolder_flag, standard_flag), ~ create_var(c(...))),
    age_middleyounger_purchase = pmap_dbl(list(age_middleyounger_flag, standard_flag), ~ create_var(c(...))),
    age_younger_purchase = pmap_dbl(list(age_younger_flag, standard_flag), ~ create_var(c(...))),
    age_mixed_purchase = pmap_dbl(list(age_mixed_flag, standard_flag), ~ create_var(c(...))),
    
    #Medians for owner-occ purchase loans
    #Note: these aren't median values -- these are summarized to tract-level medians in a subsequent step
    income_median = if_else(standard_flag == 1, income, NA_real_), 
    owner_loan_amount_median = if_else(standard_flag == 1, loan_amount, NA_real_)) %>%
  rename(owner_purchase_originations = standard_flag)

# Create all combined indicators
print(paste("Step 8: Created all combined indicators", Sys.time() ))
```

```{r producing final dataset}
rm(hmda_flags)

#List of sum variables to include in the final file
final_vars <- c(
  "owner_purchase_originations", #owner-occupied, first-lien home purchases of 1-4 unit dwellings
  
  #Investment vars
  "occupancy_investment_origination", "occupancy_investment_units_1_4", "occupancy_investment_units_5ormore",
  
  #Denominator vars
  "income_available", "race_available", "race_income_available", "age_available",
                
  #Race/ethnicity vars
  "race_white_purchase", "race_black_purchase", "race_hispanic_purchase", "race_asian_purchase", "race_nhpi_purchase", "race_asian_or_nhpi_purchase", "race_multiple_purchase",
  "race_missing_purchase",  "race_mixed_purchase", "race_aian_purchase", "race_asian_indian_purchase", "race_asian_chinese_purchase",
  "race_asian_filipino_purchase", "race_asian_japanese_purchase", "race_asian_korean_purchase", "race_asian_vietnamese_purchase",
                
  #Income vars
  "income_verylow_purchase","income_low_purchase","income_moderate_purchase","income_high_purchase",
                
  #Combined race/income vars
  "race_white_income_verylow","race_white_income_low","race_white_income_moderate","race_white_income_high",
  "race_black_income_verylow","race_black_income_low","race_black_income_moderate","race_black_income_high",
  "race_hispanic_income_verylow","race_hispanic_income_low","race_hispanic_income_moderate","race_hispanic_income_high",
  "race_aian_income_verylow","race_aian_income_low","race_aian_income_moderate","race_aian_income_high",
  "race_asian_or_nhpi_income_verylow","race_asian_or_nhpi_income_low","race_asian_or_nhpi_income_moderate","race_asian_or_nhpi_income_high",
  "race_multiple_income_verylow","race_multiple_income_low","race_multiple_income_moderate","race_multiple_income_high",
  "race_mixed_income_verylow","race_mixed_income_low","race_mixed_income_moderate","race_mixed_income_high",
  "race_missing_income_verylow","race_missing_income_low","race_missing_income_moderate","race_missing_income_high",
  
  #Age vars
  "age_older_purchase", "age_middleolder_purchase", "age_middleyounger_purchase", "age_younger_purchase", "age_mixed_purchase",
  
  #Missing vars
  "missing_tract"
)

#Summarize by tract 
print(paste("Step 9: Summarize by tract", Sys.time()))

hmda_tract <- hmda_combined2 %>%
  group_by(geo2010) %>% 
  summarise(
    across(all_of(final_vars), sum, na.rm = TRUE),
    across(matches("median"), median, na.rm = TRUE),
    ) %>% 
  left_join(
    ## joining ACS variables to the HMDA data
    acs_housing %>%
      mutate(
        #Percent owner-occupied units (ACS)
        occupancy_owneroccupied_percent = (housing_units_occupied_owner / housing_units_occupied_total) %>% round(digits = 2)
        ) %>%
      select(
        GEOID, 
        occupancy_unitsoccupied_count = housing_units_occupied_total,
        occupancy_owneroccupied_count = housing_units_occupied_owner,
        occupancy_owneroccupied_percent),
    by = c("geo2010" = "GEOID")
    ) %>%
  rename(missing_geo = missing_tract) %>% 
  arrange(geo2010) 
  
#Final cleanup
print(paste("Step 10: Final cleanup", Sys.time()))

hmda_final <- hmda_tract %>%
  mutate(invalid_geo = if_else(missing_geo > 0, 1, 0)) %>%
  select(-missing_geo)
```

```{r quality control}
## check to ensure all variables have non-zero values in some tracts
#skimr::fix_windows_histograms() ## if histograms do not render correctly, use this function and re-run
skimr::skim(hmda_final)

## this should return a dataframe with no rows
all_checks_passed = hmda_final %>%
  mutate(
    # creating variables reflecting the sum across each component variable within
    # each domain (age, income, race, race_income). these "check" variables should equal
    # the corresponding [domain]_available variable.
    age_check = rowSums(across(c(matches("age"), -matches("available"))), na.rm = T), 
    income_check = rowSums(across(c(matches("income"), -matches("race|median|available")))),
    race_check = rowSums(across(
      c(race_white_purchase, race_black_purchase, race_hispanic_purchase, race_asian_or_nhpi_purchase, 
        race_multiple_purchase, race_mixed_purchase, race_aian_purchase)), na.rm = T),
    race_income_check = rowSums(across(c(matches("race.*income"), -matches("available|missing"))), na.rm = T),
    # all tract IDs should be 11 characters
    tract_id_characters = nchar(geo2010),
    errors = case_when(
      age_check != age_available ~ "age check failed",
      income_check != income_available ~ "income check failed",
      race_check != race_available ~ "race check failed",
      race_income_check != race_income_available ~ "race-income check failed",
      tract_id_characters != 11 ~ "invalid tract id",
      T ~ NA_character_
    )
  ) %>%
  filter(!is.na(errors)) %>%
  select(errors, tract_id_characters, income_available, income_check,  matches("income"), -matches("race"), geo2010)

all_checks_passed

## check to ensure that there aren't any variables in the codebook
## that aren't in the final dataset. this should return a dataframe with no rows.
codebook %>%
  filter(!(`Name - 2021` %in% (colnames(hmda_final))))

## check to ensure there aren't any columns in the codebook
## that aren't in the final dataset. this should return an empty character vector.
colnames(hmda_final)[!(colnames(hmda_final) %in% codebook$`Name - 2021`)]
```

```{r exporting data}
#Export final CSV
print(paste("Step 11: Export CSV", Sys.time()))

write_csv(hmda_final, output_path)

#End time for log
endtime <- Sys.time()
totaltime <- endtime - starttime
print(paste("End Time:", endtime))
print(paste("Total Run Time:", totaltime))

#End of program
```

